汉字：^[\u4e00-\u9fa5]*$
Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$
域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?
InternetURL：^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$
手机号码：^(13[0-9]|14[579]|15[0-3,5-9]|16[6]|17[0135678]|18[0-9]|19[89])\d{8}$
双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))
空白行的正则表达式：\n\s*\r (可以用来删除空白行)
HTML标记的正则表达式：<(\S*?)[^>]*>.*?</\1>|<.*? />
首尾空白字符的正则表达式：^\s*|\s*$
IP地址：25[0-5]|2[0-4]\d|[0-1]\d{2}|\d{2}|\d 这是个匹配0-255数字的正则,匹配ip可由此扩展
((?:(?:25[0-5]|2[0-4]\d|[01]?\d?\d)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d?\d))

误匹配：指正则表达式所匹配的内容范围超出了所需要范围，有些文本明明不符合要求，但是被所写的正则式“击中了”。例如，如果使用\d{11}来匹配11位的手机号，\d{11}不单能匹配正确的手机号，它还会匹配98765432100这样的明显不是手机号的字符串。我们把这样的匹配称之为误匹配。

漏匹配：指正则表达式所匹配的内容所规定的范围太狭窄，有些文本确实是所需要的，但是所写的正则没有将这种情况囊括在内。例如，使用\d{18}来匹配18位的身份证号码，就会漏掉结尾是字母X的情况。

写出一条正则表达式，既可能只出现误匹配（条件写得极宽松，其范围大于目标文本），也可能只出现漏匹配（只描述了目标文本中多种情况种的一种），还可能既有误匹配又有漏匹配。例如，使用\w+\.com来匹配.com结尾的域名，既会误匹配abc_.com这样的字串（合法的域名中不含下划线，\w包含了下划线这种情况），又会漏掉ab-c.com这样的域名（合法域名中可以含中划线，但是\w不匹配中划线）。

精准的正则表达式意味着既无误匹配且无漏匹配。当然，现实中存在这样的情况：只能看到有限数量的文本，根据这些文本写规则，但是这些规则将会用到海量的文本中。这种情况下，尽可能地（如果不是完全地）消除误匹配以及漏匹配，并提升运行效率，就是我们的目标。本文所提出的经验，主要是针对这种情况。

掌握语法细节。正则表达式在各种语言中，其语法大致相同，细节各有千秋。明确所使用语言的正则的语法的细节，是写出正确、高效正则表达式的基础。例如，perl中与\w等效的匹配范围是[a-zA-Z0-9_]；perl正则式不支持肯定逆序环视中使用可变的重复（variable repetition inside lookbehind，例如(?<=.*)abc），但是.Net语法是支持这一特性的；又如，JavaScript连逆序环视（Lookbehind,如(?<=ab)c）都不支持，而perl和python是支持的。《精通正则表达式》第3章《正则表达式的特性和流派概览》明确地列出了各大派系正则的异同，这篇文章也简要地列出了几种常用语言、工具中正则的比较。对于具体使用者而言，至少应该详细了解正在使用的那种工作语言里正则的语法细节。

先粗后精，先加后减。使用正则表达式语法对于目标文本进行描述和界定，可以像画素描一样，先大致勾勒出框架，再逐步在局步实现细节。仍举刚才的手机号的例子，先界定\d{11}，总不会错；再细化为1[358]\d{9}，就向前迈了一大步（至于第二位是不是3、5、8，这里无意深究，只举这样一个例子，说明逐步细化的过程）。这样做的目的是先消除漏匹配（刚开始先尽可能多地匹配，做加法），然后再一点一点地消除误匹配（做减法）。这样有先有后，在考虑时才不易出错，从而向“不误不漏”这个目标迈进。

留有余地。所能看到的文本sample是有限的，而待匹配检验的文本是海量的，暂时不可见的。对于这样的情况，在写正则表达式时要跳出所能见到的文本的圈子，开拓思路，作出“战略性前瞻”。例如，经常收到这样的垃圾短信：“发*票”、“发#漂”。如果要写规则屏蔽这样烦人的垃圾短信，不但要能写出可以匹配当前文本的正则表达式 发[*#](?:票|漂)，还要能够想到 发.(?:票|漂|飘)之类可能出现的“变种”。这在具体的领域或许会有针对性的规则，不多言。这样做的目的是消除漏匹配，延长正则表达式的生命周期。

明确。具体说来，就是谨慎用点号这样的元字符，尽可能不用星号和加号这样的任意量词。只要能确定范围的，例如\w，就不要用点号；只要能够预测重复次数的，就不要用任意量词。例如，写析取twitter消息的脚本，假设一条消息的xml正文部分结构是<span class=”msg”>…</span>且正文中无尖括号，那么<span class=”msg”>[^<]{1,480}</span>这种写法的思路要好于<span class=”msg”>.*</span>，原因有二：一是使用[^<]，它保证了文本的范围不会超出下一个小于号所在的位置；二是明确长度范围，{1,480}，其依据是一条twitter消息大致能的字符长度范围。当然，480这个长度是否正确还可推敲，但是这种思路是值得借鉴的。说得狠一点，“滥用点号、星号和加号是不环保、不负责任的做法”。

不要让稻草压死骆驼。每使用一个普通括号()而不是非捕获型括号(?:…)，就会保留一部分内存等着你再次访问。这样的正则表达式、无限次地运行次数，无异于一根根稻草的堆加，终于能将骆驼压死。养成合理使用(?:…)括号的习惯。

宁简勿繁。将一条复杂的正则表达式拆分为两条或多条简单的正则表达式，编程难度会降低，运行效率会提升。例如用来消除行首和行尾空白字符的正则表达式s/^\s+|\s+$//g;，其运行效率理论上要低于s/^\s+//g; s/\s+$//g; 。这个例子出自《精通正则表达式》第五章，书中对它的评论是“它几乎总是最快的，而且显然最容易理解”。既快又容易理解，何乐而不为？工作中我们还有其它的理由要将C==(A|B)这样的正则表达式拆为A和B两条表达式分别执行。例如，虽然A和B这两种情况只要有一种能够击中所需要的文本模式就会成功匹配，但是如果只要有一条子表达式（例如A）会产生误匹配，那么不论其它的子表达式（例如B）效率如何之高，范围如何精准，C的总体精准度也会因A而受到影响。

巧妙定位。有时候，我们需要匹配的the，是作为单词的the（两边有空格），而不是作为单词一部分的t-h-e的有序排列（例如together中的the）。在适当的时候用上^，$，\b等等定位锚点，能有效提升找到成功匹配、淘汰不成功匹配的效率。




分组： (exp) 匹配exp,并捕获文本到自动命名的组里   (?<name>exp)  匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp)
(?:exp)  匹配exp,不捕获匹配的文本，也不给此分组分配组号  \1代表分组1匹配的文本
组号分配：从左向右扫描两遍，第一遍只给未命名组分配，第二遍只给命名组分配。所有命名组的组号都大于未命名的组号。
(?:exp)剥夺一个分组对组号分配的参与权(非捕获分组)
量词使用：/(ab)+/  ab至少一次     /ab+/  b至少一次     对多个字符使用数量词，必需要用圆括号
\b 边界（前后位置不全为\w）        \n换行    \d数字     \s空白符    \w字母数字下划线汉字   ^ 字符串的开始   $ 字符串的结束  []或
反义：\W 不是字母，数字，下划线，汉字的字符     \S 非空白符    \D 非数字  \B非边界  [^aeiou]非aeiou这几个字母
限定符：   *至少零次  +至少一次  ? 至多一次 {n} n次  {n,}至少n次  {n,m}n到m次
元字符： . 非换行任意字符 
分支匹配：|  前项匹配不成功，再后项。
零宽断言： (?=exp)  匹配exp前面的位置      (?<=exp)  匹配exp后面的位置
(?!exp)   匹配后面跟的不是exp的位置   (?<!exp)   匹配前面不是exp的位置  
注释： (?#comment)  这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读
量词默认贪婪（尽可能多），懒惰（尽可能少）（以量词跟“？”开启）
处理选项：IgnoreCase(忽略大小写)  Multiline(多行模式)  (在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.) 
Singleline(单行模式)  更改.的含义，使它与每一个字符匹配（包括换行符\n）。  
IgnorePatternWhitespace(忽略空白)   忽略表达式中的非转义空白并启用由#标记的注释。
ExplicitCapture(显式捕获)   仅捕获已被显式命名的组。
注：单行模式，多行模式可同时开启
平衡组/递归匹配
(?'group') 把捕获的内容命名为group,并压入堆栈(Stack)
(?'-group') 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败
(?(group)yes|no) 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分
(?!) 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败
匹配嵌套的<div>标签：<div[^>]*>[^<>]*(((?'Open'<div[^>]*>)[^<>]*)+((?'-Open'</div>)[^<>]*)+)*(?(Open)(?!))</div>.
\a     报警字符(打印它的效果是电脑嘀一声)                    \b       通常是单词分界位置，但如果在字符类里使用代表退格
\t      制表符，Tab                                          \r       回车
\v      竖向制表符                                          \f       换页符
\n      换行符                                              \e       Escape
\0nn    ASCII代码中八进制代码为nn的字符                  \xnn      ASCII代码中十六进制代码为nn的字符
\unnnn    Unicode代码中十六进制代码为nnnn的字符        \cN       ASCII控制字符。比如\cC代表Ctrl+C
\A      字符串开头(类似^，但不受处理多行选项的影响)      \Z        字符串结尾或行尾(不受处理多行选项的影响)
\z     字符串结尾(类似$，但不受处理多行选项的影响)        \G       当前搜索的开头
\p{name}     Unicode中命名为name的字符类，例如\p{IsGreek}    (?>exp)        贪婪子表达式
(?<x>-<y>exp)      平衡组                              (?im-nsx:exp)    在子表达式exp中改变处理选项

(?im-nsx) 为表达式后面的部分改变处理选项
(?(exp)yes|no)  把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no
(?(name)yes|no) 如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no

正则表达式性能测试工具推荐、优化工具推荐(regexbuddy推荐)。
常见正则表达式引擎
引擎	区别点
DFA
Deterministic finite automaton 
确定型有穷自动机	DFA引擎它们不要求回溯，所以匹配速度快！DFA引擎还可以匹配最长的可能的字符串。不过DFA引擎只包含有限的状态，所以它不能匹配具有反向引用的模式，还不可以捕获子表达式。代表性有：awk,egrep,flex,lex,MySQL,Procmail
NFA
Non-deterministic finite automaton　非确定型有穷自动机，又分为传统NFA,Posix NFA	传统的NFA引擎运行所谓的“贪婪的”匹配回溯算法（longest-leftmost），以指定顺序测试正则表达式的所有可能的扩展并接受第一个匹配项。传统的NFA回溯可以访问完全相同的状态多次，在最坏情况下，它的执行速度可能非常慢，但它支持子匹配。代表性有：GNU Emacs,Java,ergp,less,more,.NET语言,
PCRE library,Perl,PHP,Python,Ruby,sed,vi等，一般高级语言都采用该模式。
占有字符和零宽度
正则表达式匹配过程中，如果子表达式匹配到的是字符内容，而非位置，并被保存到最终的匹配结果中，那么就认为这个子表达式是占有字符的；如果子表达式匹配的仅仅是位置，或者匹配的内容并不保存到最终的匹配结果中，那么就认为这个子表达式是零宽度的。占有字符是互斥的，零宽度是非互斥的。也就是一个字符，同一时间只能由一个子表达式匹配，而一个位置，却可以同时由多个零宽度的子表达式匹配。常见零宽字符有：^，(?=)等

Demo2:源字符DEF,对应标记是：0D1E2F3，匹配正则表达式是：/D\w+F/
过程可以理解为：首先由正则表达式字符 /D/ 取得控制权，从位置0开始匹配，由 /D/ 来匹配“D”，匹配成功，控制权交给字符 /\w+/ ；由于“D”已被 /D/ 匹配，所以 /\w+/ 从位置1开始尝试匹配，\w+贪婪模式，会记录一个备选状态，默认会匹配最长字符，直接匹配到EF，并且匹配成功，当前位置3了。并且把控制权交给 /F/ ；由 /F/ 匹配失败，\w+匹配会回溯一位，当前位置变成2。并把控制权交个/F/，由/F/匹配字符F成功。因此\w+这里匹配E字符,匹配完成！

Demo3:源字符DEF,对应标记是：0D1E2F3，匹配正则表达式是：/^(?=D)[D-F]+$/
过程可以理解为：元字符 /^/ 和 /$/ 匹配的只是位置，顺序环视 /(?=D)/ （匹配当前位置，右边是否有字符“D”字符出现）只进行匹配，并不占有字符，也不将匹配的内容保存到最终的匹配结果，所以都是零宽度的。 首先由元字符 /^/ 取得控制权，从位置0开始匹配， /^/ 匹配的就是开始位置“位置0”，匹配成功，控制权交给顺序环视 /(?=D)/；/(?=D])/ 要求它所在位置右侧必须是字母”D”才能匹配成功，零宽度的子表达式之间是不互斥的，即同一个位置可以同时由多个零宽度子表达式匹配，所以它也是从位置0尝试进行匹配，位置0的右侧是字符“D”，符合要求，匹配成功，控制权交给 /[D-F]+/ ；因为 /(?=D)/ 只进行匹配，并不将匹配到的内容保存到最后结果，并且 /(?=D)/ 匹配成功的位置是位置0，所以 /[D-F]+/ 也是从位置0开始尝试匹配的， /[D-F]+/ 首先尝试匹配“D”，匹配成功，继续尝试匹配，直到匹配完”EF”，这时已经匹配到位置3，位置3的右侧已没有字符，这时会把控制权交给 /$/，元字符 /$/ 从位置3开始尝试匹配，它匹配的是结束位置，也就是“位置3”，匹配成功。此时正则表达式匹配完成，报告匹配成功。匹配结果为“DEF”，开始位置为0，结束位置为3。其中 /^/ 匹配位置0， /(?=D)/ 匹配位置0， /[D-F]+/ 匹配字符串“DEF”， /$/ 匹配位置3。


1.在没有g标识符时，match和exec方法效果是一样的；有g标识符时，exec方法可以提供最完整的匹配结果。 
2.这里顺便提一下RegExp.test()方法，它是exec方法的简化版，有匹配结果就返回true，没有匹配结果就返回false，执行过程与exec是一样的。相当于 (p.exec(s) != null)。 
3.RegExp的lastIndex属性在有g标识符，且在exec和test方法中是有效的,其他地方是无效的。



中文字符： [u4e00-u9fa5]
双字节字符：[^x00-xff]
首尾空白字符：^s*|s*$
Email地址：w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*
QQ：[1-9][0-9]{4,}
中国邮政编码：[1-9]d{5}(?!d)
