标准的全景图是一张2：1的图像,由球面进行等距圆柱投影
展示的过程就是 逆等距圆柱投影 过程,使用webgl或者thress.js

使用thress.js注意面朝内
//新建一个球体
var geometry = new THREE.SphereGeometry( 500, 60, 40 );
//沿x轴进行-1的scale，让球体的面朝内（因为我们将从球内进行观看）。
geometry.scale( - 1, 1, 1 );
//载入一张全景图生成threejs中可以使用的材质
var material = new THREE.MeshBasicMaterial( {
    map: new THREE.TextureLoader().load( 'panoPic.jpg' )
} );
//将几何体和材质进行结合。
mesh = new THREE.Mesh( geometry, material );


webgl兼容性,thress.js性能,css3


根据全景图的原理,我们是把视角放在球的中心，通过从球心观看球面上正式场景在球面上的映像从而产生一种空间中全方位的视觉体验，同理，对于立方体，应该也可以使用相同的方式来实现。而我们要做，就是把球面上的像素点映射到立方体上。
s2c
说了基本的原理，接下来就是进行数学建模了。首先我们建立一个球坐标系，坐标系描述的变量分别为半径r,竖直方向上的夹角θ,水平方向上的夹角ø，对于球体，我们可以假定
r=1
0 < θ < π
 -π/4 < ø < 7π/4
这样我们就可以得到球面上的各个点在直角坐标系中的x,y,z
x= r sin θ cos ø
y= r sin θ sin ø
z= r cos θ
对于球面到立方体上的投影，我们需要的是角度θ和ø相同时，延长球的半径r直到和立方体的面相交，假设这个长度是R，由于我们设了半径r是1所以球面上的点为 (sin θ cos ø, sin θ sin ø, cos θ) 对应的立方体上的点是(Rsin θ cos ø, Rsin θ sin ø, Rcos θ)
如果我们要求x=1这个平面上的点，则
1=Rsin θ cos ø
则可以求出来
R= 1/(sin θ cos ø)
所以在x平面上映射的点就是
(1, tan ø, cot θ / cos ø)
在立方体另外的五个平面上的投影也可以类似地得出。通过上述方法转换一张全景图，可以得到以下结果。
结果1
离我们想要的效果还有一些差距，图中似乎多了一些黑色的线。导致这种现象的原因是，由于我们的处理是以像素为单位来进行处理的，通过遍历球面图上的每个像素然后投影到立方体上的面来实现。经过这种方式进行投射之后，立方体的面上就会有一些像素被重复设置，而一些地方的像素就会缺失，比如图中的黑色部分（由于底色的黑色的）。为了解决这个问题，我们可以通过逆向的方法来解决，也就是遍历立方体上面上的每个点，求得映射到球面上的位置，然后获取球面上最接近的位置的像素。
